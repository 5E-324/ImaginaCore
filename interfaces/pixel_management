#include <concepts>
#include <Imagina/types>

namespace Imagina {
	struct _GpuTexture;
	using GpuTexture = _GpuTexture *;

	class IGraphics;

	template<typename T>
	concept IGraphicsImpl = requires {
		{&T::CreateTexture}->std::convertible_to<GpuTexture (T:: *)()>;
		{&T::DeleteTexture}->std::convertible_to<void (T:: *)(GpuTexture texture)>;
		{&T::SetTextureImage}->std::convertible_to<void (T:: *)(GpuTexture texture, size_t width, size_t height, float *pixels)>;
		{&T::UpdateTextureImage}->std::convertible_to<void (T:: *)(GpuTexture texture, size_t width, size_t height, float *pixels)>;
		requires !std::is_same_v<T, IGraphics>;
	};

	template<IGraphicsImpl T>
	void _IIG_IGraphics_Release(void *instance) {
		delete (T *)instance;
	}

	template<IGraphicsImpl T>
	GpuTexture _IIG_IGraphics_CreateTexture(void *instance) {
		return ((T *)instance)->T::CreateTexture();
	}

	template<IGraphicsImpl T>
	void _IIG_IGraphics_DeleteTexture(void *instance, GpuTexture texture) {
		return ((T *)instance)->T::DeleteTexture(texture);
	}

	template<IGraphicsImpl T>
	void _IIG_IGraphics_SetTextureImage(void *instance, GpuTexture texture, size_t width, size_t height, float *pixels) {
		return ((T *)instance)->T::SetTextureImage(texture, width, height, pixels);
	}

	template<IGraphicsImpl T>
	void _IIG_IGraphics_UpdateTextureImage(void *instance, GpuTexture texture, size_t width, size_t height, float *pixels) {
		return ((T *)instance)->T::UpdateTextureImage(texture, width, height, pixels);
	}

	struct IGraphicsVTable {
		void *reserved = nullptr; // Must be null
		void (*Release)(void *instance);

		GpuTexture (*CreateTexture)(void *instance);
		void (*DeleteTexture)(void *instance, GpuTexture texture);
		void (*SetTextureImage)(void *instance, GpuTexture texture, size_t width, size_t height, float *pixels);
		void (*UpdateTextureImage)(void *instance, GpuTexture texture, size_t width, size_t height, float *pixels);

		template<IGraphicsImpl T>
		static IGraphicsVTable OfType(void (*release)(void *instance) = _IIG_IGraphics_Release<T>) {
			IGraphicsVTable result;
			result.Release = release;
			result.CreateTexture = _IIG_IGraphics_CreateTexture<T>;
			result.DeleteTexture = _IIG_IGraphics_DeleteTexture<T>;
			result.SetTextureImage = _IIG_IGraphics_SetTextureImage<T>;
			result.UpdateTextureImage = _IIG_IGraphics_UpdateTextureImage<T>;

			return result;
		}

		template<IGraphicsImpl T>
		static IGraphicsVTable value;
	};

	class IGraphics {
		void *instance;
		const IGraphicsVTable *vTable;

	public:
		IGraphics() = default;
		IGraphics(const IGraphics &) = default;
		IGraphics(IGraphics &&) = default;
		IGraphics(std::nullptr_t) : instance(nullptr), vTable(nullptr) {}

		IGraphics(void *instance, const IGraphicsVTable *vTable) : instance(instance), vTable(vTable) {}

		template<IGraphicsImpl T>
		IGraphics(T &instance) : instance(&instance), vTable(&IGraphicsVTable::value<T>) {}

		template<IGraphicsImpl T>
		IGraphics(T *instance) : instance(instance), vTable(&IGraphicsVTable::value<T>) {}

		IGraphics &operator=(const IGraphics &) = default;
		IGraphics &operator=(IGraphics &&) = default;

		IGraphics &operator=(std::nullptr_t) { instance = nullptr; vTable = nullptr; return *this; }
		bool operator==(std::nullptr_t) { return instance == nullptr; }
		bool operator!=(std::nullptr_t) { return instance != nullptr; }

		operator bool() { return instance != nullptr; }

		template<IGraphicsImpl T>
		explicit operator T *() { return (T *)instance; }

		void Release() {
			vTable->Release(instance);
		}

		GpuTexture CreateTexture() {
			return vTable->CreateTexture(instance);
		}

		void DeleteTexture(GpuTexture texture) {
			return vTable->DeleteTexture(instance, texture);
		}

		void SetTextureImage(GpuTexture texture, size_t width, size_t height, float *pixels) {
			return vTable->SetTextureImage(instance, texture, width, height, pixels);
		}

		void UpdateTextureImage(GpuTexture texture, size_t width, size_t height, float *pixels) {
			return vTable->UpdateTextureImage(instance, texture, width, height, pixels);
		}
	};

	class IRasterizingInterface;

	template<typename T>
	concept IRasterizingInterfaceImpl = requires {
		{&T::GetPixel}->std::convertible_to<bool (T:: *)(HRReal &x, HRReal &y)>;
		{&T::GetDdx}->std::convertible_to<void (T:: *)(HRReal &x, HRReal &y)>;
		{&T::GetDdy}->std::convertible_to<void (T:: *)(HRReal &x, HRReal &y)>;
		{&T::WriteResults}->std::convertible_to<void (T:: *)(void *value)>;
		requires !std::is_same_v<T, IRasterizingInterface>;
	};

	template<IRasterizingInterfaceImpl T>
	void _IIG_IRasterizingInterface_Release(void *instance) {
		delete (T *)instance;
	}

	template<IRasterizingInterfaceImpl T>
	bool _IIG_IRasterizingInterface_GetPixel(void *instance, HRReal &x, HRReal &y) {
		return ((T *)instance)->T::GetPixel(x, y);
	}

	template<IRasterizingInterfaceImpl T>
	void _IIG_IRasterizingInterface_GetDdx(void *instance, HRReal &x, HRReal &y) {
		return ((T *)instance)->T::GetDdx(x, y);
	}

	template<IRasterizingInterfaceImpl T>
	void _IIG_IRasterizingInterface_GetDdy(void *instance, HRReal &x, HRReal &y) {
		return ((T *)instance)->T::GetDdy(x, y);
	}

	template<IRasterizingInterfaceImpl T>
	void _IIG_IRasterizingInterface_WriteResults(void *instance, void *value) {
		return ((T *)instance)->T::WriteResults(value);
	}

	struct IRasterizingInterfaceVTable {
		void *reserved = nullptr; // Must be null
		void (*Release)(void *instance);

		bool (*GetPixel)(void *instance, HRReal &x, HRReal &y);
		void (*GetDdx)(void *instance, HRReal &x, HRReal &y);
		void (*GetDdy)(void *instance, HRReal &x, HRReal &y);
		void (*WriteResults)(void *instance, void *value);

		template<IRasterizingInterfaceImpl T>
		static IRasterizingInterfaceVTable OfType(void (*release)(void *instance) = _IIG_IRasterizingInterface_Release<T>) {
			IRasterizingInterfaceVTable result;
			result.Release = release;
			result.GetPixel = _IIG_IRasterizingInterface_GetPixel<T>;
			result.GetDdx = _IIG_IRasterizingInterface_GetDdx<T>;
			result.GetDdy = _IIG_IRasterizingInterface_GetDdy<T>;
			result.WriteResults = _IIG_IRasterizingInterface_WriteResults<T>;

			return result;
		}

		template<IRasterizingInterfaceImpl T>
		static IRasterizingInterfaceVTable value;
	};

	class IRasterizingInterface {
		void *instance;
		const IRasterizingInterfaceVTable *vTable;

	public:
		IRasterizingInterface() = default;
		IRasterizingInterface(const IRasterizingInterface &) = default;
		IRasterizingInterface(IRasterizingInterface &&) = default;
		IRasterizingInterface(std::nullptr_t) : instance(nullptr), vTable(nullptr) {}

		IRasterizingInterface(void *instance, const IRasterizingInterfaceVTable *vTable) : instance(instance), vTable(vTable) {}

		template<IRasterizingInterfaceImpl T>
		IRasterizingInterface(T &instance) : instance(&instance), vTable(&IRasterizingInterfaceVTable::value<T>) {}

		template<IRasterizingInterfaceImpl T>
		IRasterizingInterface(T *instance) : instance(instance), vTable(&IRasterizingInterfaceVTable::value<T>) {}

		IRasterizingInterface &operator=(const IRasterizingInterface &) = default;
		IRasterizingInterface &operator=(IRasterizingInterface &&) = default;

		IRasterizingInterface &operator=(std::nullptr_t) { instance = nullptr; vTable = nullptr; return *this; }
		bool operator==(std::nullptr_t) { return instance == nullptr; }
		bool operator!=(std::nullptr_t) { return instance != nullptr; }

		operator bool() { return instance != nullptr; }

		template<IRasterizingInterfaceImpl T>
		explicit operator T *() { return (T *)instance; }

		void Release() {
			vTable->Release(instance);
		}

		bool GetPixel(HRReal &x, HRReal &y) {
			return vTable->GetPixel(instance, x, y);
		}

		void GetDdx(HRReal &x, HRReal &y) {
			return vTable->GetDdx(instance, x, y);
		}

		void GetDdy(HRReal &x, HRReal &y) {
			return vTable->GetDdy(instance, x, y);
		}

		void WriteResults(void *value) {
			return vTable->WriteResults(instance, value);
		}
	};

	class IRasterizer;

	template<typename T>
	concept IRasterizerImpl = requires {
		{&T::Cancel}->std::convertible_to<void (T:: *)()>;
		{&T::GetRasterizingInterface}->std::convertible_to<IRasterizingInterface (T:: *)()>;
		{&T::FreeRasterizingInterface}->std::convertible_to<void (T:: *)(IRasterizingInterface Interface)>;
		requires !std::is_same_v<T, IRasterizer>;
	};

	template<IRasterizerImpl T>
	void _IIG_IRasterizer_Release(void *instance) {
		delete (T *)instance;
	}

	template<IRasterizerImpl T>
	void _IIG_IRasterizer_Cancel(void *instance) {
		return ((T *)instance)->T::Cancel();
	}

	template<IRasterizerImpl T>
	IRasterizingInterface _IIG_IRasterizer_GetRasterizingInterface(void *instance) {
		return ((T *)instance)->T::GetRasterizingInterface();
	}

	template<IRasterizerImpl T>
	void _IIG_IRasterizer_FreeRasterizingInterface(void *instance, IRasterizingInterface Interface) {
		return ((T *)instance)->T::FreeRasterizingInterface(Interface);
	}

	struct IRasterizerVTable {
		void *reserved = nullptr; // Must be null
		void (*Release)(void *instance);

		void (*Cancel)(void *instance);
		IRasterizingInterface (*GetRasterizingInterface)(void *instance);
		void (*FreeRasterizingInterface)(void *instance, IRasterizingInterface Interface);

		template<IRasterizerImpl T>
		static IRasterizerVTable OfType(void (*release)(void *instance) = _IIG_IRasterizer_Release<T>) {
			IRasterizerVTable result;
			result.Release = release;
			result.Cancel = _IIG_IRasterizer_Cancel<T>;
			result.GetRasterizingInterface = _IIG_IRasterizer_GetRasterizingInterface<T>;
			result.FreeRasterizingInterface = _IIG_IRasterizer_FreeRasterizingInterface<T>;

			return result;
		}

		template<IRasterizerImpl T>
		static IRasterizerVTable value;
	};

	class IRasterizer {
		void *instance;
		const IRasterizerVTable *vTable;

	public:
		IRasterizer() = default;
		IRasterizer(const IRasterizer &) = default;
		IRasterizer(IRasterizer &&) = default;
		IRasterizer(std::nullptr_t) : instance(nullptr), vTable(nullptr) {}

		IRasterizer(void *instance, const IRasterizerVTable *vTable) : instance(instance), vTable(vTable) {}

		template<IRasterizerImpl T>
		IRasterizer(T &instance) : instance(&instance), vTable(&IRasterizerVTable::value<T>) {}

		template<IRasterizerImpl T>
		IRasterizer(T *instance) : instance(instance), vTable(&IRasterizerVTable::value<T>) {}

		IRasterizer &operator=(const IRasterizer &) = default;
		IRasterizer &operator=(IRasterizer &&) = default;

		IRasterizer &operator=(std::nullptr_t) { instance = nullptr; vTable = nullptr; return *this; }
		bool operator==(std::nullptr_t) { return instance == nullptr; }
		bool operator!=(std::nullptr_t) { return instance != nullptr; }

		operator bool() { return instance != nullptr; }

		template<IRasterizerImpl T>
		explicit operator T *() { return (T *)instance; }

		void Release() {
			vTable->Release(instance);
		}

		void Cancel() {
			return vTable->Cancel(instance);
		}

		IRasterizingInterface GetRasterizingInterface() {
			return vTable->GetRasterizingInterface(instance);
		}

		void FreeRasterizingInterface(IRasterizingInterface Interface) {
			return vTable->FreeRasterizingInterface(instance, Interface);
		}
	};
}