#include <concepts>
#include "../types"

namespace Imagina {
	class IRasterizingInterface;

	template<typename T>
	concept IRasterizingInterfaceImpl = requires {
		{&T::GetPixel}->std::same_as<bool (T:: *)(HRReal &x, HRReal &y)>;
		{&T::GetDdx}->std::same_as<void (T:: *)(HRReal &x, HRReal &y)>;
		{&T::GetDdy}->std::same_as<void (T:: *)(HRReal &x, HRReal &y)>;
		{&T::WriteResults}->std::same_as<void (T:: *)(void *value)>;
		requires !std::is_same_v<T, IRasterizingInterface>;
	};

	template<IRasterizingInterfaceImpl T>
	bool _IIG_IRasterizingInterface_GetPixel(void *instance, HRReal &x, HRReal &y) {
		return ((T *)instance)->T::GetPixel(x, y);
	}

	template<IRasterizingInterfaceImpl T>
	void _IIG_IRasterizingInterface_GetDdx(void *instance, HRReal &x, HRReal &y) {
		return ((T *)instance)->T::GetDdx(x, y);
	}

	template<IRasterizingInterfaceImpl T>
	void _IIG_IRasterizingInterface_GetDdy(void *instance, HRReal &x, HRReal &y) {
		return ((T *)instance)->T::GetDdy(x, y);
	}

	template<IRasterizingInterfaceImpl T>
	void _IIG_IRasterizingInterface_WriteResults(void *instance, void *value) {
		return ((T *)instance)->T::WriteResults(value);
	}

	template<IRasterizingInterfaceImpl T>
	void _IIG_IRasterizingInterface_Release(void *instance) {
		delete (T *)instance;
	}

	struct IRasterizingInterfaceVTable {
		void *reserved; // Must be zero
		bool (*GetPixel)(void *instance, HRReal &x, HRReal &y);
		void (*GetDdx)(void *instance, HRReal &x, HRReal &y);
		void (*GetDdy)(void *instance, HRReal &x, HRReal &y);
		void (*WriteResults)(void *instance, void *value);

		void (*Release)(void *instance);

		template<IRasterizingInterfaceImpl T>
		static IRasterizingInterfaceVTable OfType() {
			IRasterizingInterfaceVTable result;
			result.GetPixel = _IIG_IRasterizingInterface_GetPixel<T>;
			result.GetDdx = _IIG_IRasterizingInterface_GetDdx<T>;
			result.GetDdy = _IIG_IRasterizingInterface_GetDdy<T>;
			result.WriteResults = _IIG_IRasterizingInterface_WriteResults<T>;
			result.Release = _IIG_IRasterizingInterface_Release<T>;
			return result;
		}

		template<IRasterizingInterfaceImpl T>
		static IRasterizingInterfaceVTable value;
	};

	class IRasterizingInterface {
		void *instance;
		const IRasterizingInterfaceVTable *vTable;

	public:
		IRasterizingInterface() = default;
		IRasterizingInterface(const IRasterizingInterface &) = default;
		IRasterizingInterface(IRasterizingInterface &&) = default;

		template<IRasterizingInterfaceImpl T>
		IRasterizingInterface(T &instance) : instance(&instance), vTable(&IRasterizingInterfaceVTable::value<T>) {}

		IRasterizingInterface &operator=(const IRasterizingInterface &) = default;
		IRasterizingInterface &operator=(IRasterizingInterface &&) = default;

		template<IRasterizingInterfaceImpl T>
		explicit operator T *() { return (T *)instance; }

		bool GetPixel(HRReal &x, HRReal &y) {
			return vTable->GetPixel(instance, x, y);
		}

		void GetDdx(HRReal &x, HRReal &y) {
			return vTable->GetDdx(instance, x, y);
		}

		void GetDdy(HRReal &x, HRReal &y) {
			return vTable->GetDdy(instance, x, y);
		}

		void WriteResults(void *value) {
			return vTable->WriteResults(instance, value);
		}

		void Release() {
			vTable->Release(instance);
		}
	};

	class IRasterizer;

	template<typename T>
	concept IRasterizerImpl = requires {
		{&T::Cancel}->std::same_as<void (T:: *)()>;
		{&T::GetRasterizingInterface}->std::same_as<IRasterizingInterface (T:: *)()>;
		{&T::FreeRasterizingInterface}->std::same_as<void (T:: *)(IRasterizingInterface Interface)>;
		requires !std::is_same_v<T, IRasterizer>;
	};

	template<IRasterizerImpl T>
	void _IIG_IRasterizer_Cancel(void *instance) {
		return ((T *)instance)->T::Cancel();
	}

	template<IRasterizerImpl T>
	IRasterizingInterface _IIG_IRasterizer_GetRasterizingInterface(void *instance) {
		return ((T *)instance)->T::GetRasterizingInterface();
	}

	template<IRasterizerImpl T>
	void _IIG_IRasterizer_FreeRasterizingInterface(void *instance, IRasterizingInterface Interface) {
		return ((T *)instance)->T::FreeRasterizingInterface(Interface);
	}

	template<IRasterizerImpl T>
	void _IIG_IRasterizer_Release(void *instance) {
		delete (T *)instance;
	}

	struct IRasterizerVTable {
		void *reserved; // Must be zero
		void (*Cancel)(void *instance);
		IRasterizingInterface (*GetRasterizingInterface)(void *instance);
		void (*FreeRasterizingInterface)(void *instance, IRasterizingInterface Interface);

		void (*Release)(void *instance);

		template<IRasterizerImpl T>
		static IRasterizerVTable OfType() {
			IRasterizerVTable result;
			result.Cancel = _IIG_IRasterizer_Cancel<T>;
			result.GetRasterizingInterface = _IIG_IRasterizer_GetRasterizingInterface<T>;
			result.FreeRasterizingInterface = _IIG_IRasterizer_FreeRasterizingInterface<T>;
			result.Release = _IIG_IRasterizer_Release<T>;
			return result;
		}

		template<IRasterizerImpl T>
		static IRasterizerVTable value;
	};

	class IRasterizer {
		void *instance;
		const IRasterizerVTable *vTable;

	public:
		IRasterizer() = default;
		IRasterizer(const IRasterizer &) = default;
		IRasterizer(IRasterizer &&) = default;

		template<IRasterizerImpl T>
		IRasterizer(T &instance) : instance(&instance), vTable(&IRasterizerVTable::value<T>) {}

		IRasterizer &operator=(const IRasterizer &) = default;
		IRasterizer &operator=(IRasterizer &&) = default;

		template<IRasterizerImpl T>
		explicit operator T *() { return (T *)instance; }

		void Cancel() {
			return vTable->Cancel(instance);
		}

		IRasterizingInterface GetRasterizingInterface() {
			return vTable->GetRasterizingInterface(instance);
		}

		void FreeRasterizingInterface(IRasterizingInterface Interface) {
			return vTable->FreeRasterizingInterface(instance, Interface);
		}

		void Release() {
			vTable->Release(instance);
		}
	};
}